---
title: albacorn 개인 프로젝트 과정 

layout: single

author_profile: true

read_time: false

comments: true

share: true

related: true

categories:
- Java

tag:
- spring

description: Java, Spring에 대해 공부하는 것 정리하자.

meta_keywords: Java, Spring

last_modified_at: '2021-01-09 21:00:00 +08000'

toc: true

toc_sticky: true

toc_label: 목차
popular: true
---
<br>
프로젝트 시작하기
- [spring.start.io에서 프로젝트 만들기](https://start.spring.io/)
- [h2 데이터베이스 다운로드 하기](https://www.h2database.com)

H2 데이터베이스 설정하기
- 실행 권한이 없으므로 chomod 755 h2.sh 명령어 실행하기.
- jdbc:h2:~/projectname
- ~/projectname.mv.db 파일 생성 되었는지 확인.
- 생성 후 jdbc:h2:tcp://localhost/~/projectname 으로 접속 가능.

projectname은 자신의 프로젝트명으로 바꾸어 DB를 생성 하도록 한다.


## 문제: User 기본 키는 무엇으로 지정해야 할까?

```java
@GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
```
원래 처음에 Spring CRUD를 배울 때 이렇게 1부터 순차적으로 증가 하도록 만들었다.
하지만 실무에서는 Long 값을 사용하지 않는다고 한다.

## 해결: User 기본키는 UUID를 활용하자!

```java
@Id
    @GeneratedValue(generator = "uuid2")
    @GenericGenerator(name = "uuid2", strategy = "uuid2")
    @Column(columnDefinition = "BINARY(16)")
    private UUID id;
```

> 공식 문서  
> [하이버네이트 기본 키 생성 전략](https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#identifiers-generators-auto)  

> 블로그 링크  
>[깃허브 기본전략을 사용하면 DB 샤딩 할때 생기는 문제](https://github.com/LeoHeo/spring-tips/blob/master/jpa-uuid.md)  
>[JPA 키 생성 전략에 대해 잘 정리 해둔 블로그](https://gmlwjd9405.github.io/2019/08/12/primary-key-mapping.html)  
>[UUID사용에 관한 자세한 컬리 기술 블로그](https://helloworld.kurly.com/blog/jpa-uuid-sapjil/)  

JPA는 세가지의 기본 키 생성 전략을 갖고 있다.

**IDENTITY**
- 기본키 생성을 데이터 베이스에 위임한다.
주로 MySQL, PostgresSQL, SQL Server, DB2에서 사용된다.
  
**SEQUENCE**
- 데이터베이스 시퀀스를 사용해서 기본 키를 할당한다.
데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트이다.
  
**TABLE**
  - 키 생성 테이블을 사용한다.
  
기본 키 생성 전략은 데이터 베이스 의존적인 설정입니다.  
DB Sharding을 할 경우 id값이 유일하지 않을 수 있다고 합니다.


## 문제 : 기본 엔티티 생성 테스트는 어떻게 하지?  

엔티티를 생성 하고 디비를 연결해서 테스트 하고자 하면 Controller까지 구현 한 다음에 POSTMAN으로 쿼리를  
보내고 DB에서 확인하는 약간 과정이 복잡한 테스트 방법 밖에 알지 못했습니다.  

## 해결 : DataJpaTest로 레포지토리만 테스트 하자! 

인 메모리 임베디드 데이터베이스는 빠르고 설치가 필요하지 않기 때문에 테스트에 용이하다고 합니다.  
아래와 같이 TestEntityManay와 assertj의 assertThat를 활용해서 기본 엔티티를 검증 할 수 있습니다.

```java
@DataJpaTest
public class StoreRepositoryTest {

    @Autowired
    StoreRepository storeRepository;

    @Autowired
    StoreUserRepository storeUserRepository;

    @Autowired
    TestEntityManager tm;

    @Test
    public void createStore() throws Exception {
        //given
        Address storeAddress = new Address("seoul", "songpa-dong", "4242-42");
        Address userAddress = new Address("seoul", "gaepo-dong", "4242-42");
        StoreUser storeUser = new StoreUser("42seouler", userAddress);
        tm.persist(storeUser);
        Store store = new Store(storeUser,"store", storeAddress);
        tm.persist(store);
        //when
        Store findStore = storeRepository.findById(store.getId()).orElseThrow();
        StoreUser findStoreUser = storeUserRepository.findById(storeUser.getId()).orElseThrow();
        //then
        // 스토어의 유저 검증
        assertThat(findStore.getStoreUser()).isEqualTo(findStoreUser);
        assertThat(findStore.getStoreUser().getId()).isEqualTo(findStoreUser.getId());
        // 스토어 아이디 검증
        assertThat(findStore.getId()).isEqualTo(store.getId());
        // 스토어 이름 검증
        assertThat(findStore.getName()).isEqualTo(store.getName());
        // 스토어 주소 검증
        assertThat(findStore.getAddress().getStreet()).isEqualTo(store.getAddress().getStreet());
        assertThat(findStore.getAddress().getZipcode()).isEqualTo(store.getAddress().getZipcode());
        assertThat(findStore.getAddress().getCity()).isEqualTo(store.getAddress().getCity());
    }
}
```

> 공식 문서  
[스프링 부트 테스트 방법](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing)  
[스프링 테스트 소개](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testing-introduction)  
[DataJpaTest 어노테이션 사용법](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test)

spring-boot-starter-test에서는 아래와 같은 테스트 라이브러리를 포함하고있습니다.

**JUnit 5** : Java 애플리케이션 단위 테스트를위한 사실상의 표준입니다.  
**Spring** Test & Spring Boot Test : Spring Boot 애플리케이션을위한 유틸리티 및 통합 테스트 지원.  
**AssertJ** : 유창한 주장 라이브러리.  
**Hamcrest** : matcher 객체의 라이브러리 (제약 조건 또는 술어라고도 함).  
**Mockito** : 자바 모의 프레임 워크.  
**JSONassert** : JSON 용 어설 션 라이브러리입니다.  
**JsonPath** : JSON 용 XPath.

## 문제 : 서비스 계층은 어떻게 테스트 할까?

별도의 오류 검증 로직은 없지만 Dto를 받아서 유저를 생성하는 서비스 계층을 테스트 하려고 했습니다.
그런데 registerStoreUser를 실행하면 내부에 repository메서드를 실행하게 됩니다. 그렇게 된다면 다른 영역의 함수를 호출 해야 검증 할 수 있기 때문에 맞지 않다고 생각 했습니다.
```java
import java.util.UUID;

@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class StoreUserServiceImpl implements StoreUserService {

    private final StoreUserRepository storeUserRepository;

    @Override
    public UUID registerStoreUser(StoreUserCmdDto dto) {
        StoreUser storeUser = transferDtoToEntity(dto);
        StoreUser saveStoreUser = storeUserRepository.save(storeUser);
        return saveStoreUser.getId();
    }

    public StoreUser transferDtoToEntity(StoreUserCmdDto dto) {
        return new StoreUser(dto.getName(), dto.getAddress());
    }
}
```

## 해결 : Mockito를 사용해서 테스트 하자!

이번에는 docs로 잘 찾질 못해서 블로그를 참고해서 테스트 케이스를 작성했다.
Repository를 Mock객체로 변경했고 만약에 별도의 when, thenreturn을 사용하지 않았다면 null
객체를 반환 하면서 NullPointerException이 발생하게 된다. 구현 된 repository를 사용 하지 않고도 서비스 계층을 테스트 할 수 있게 되었다.

```java
@Test
public void 유저등록하기() throws Exception {
        //given
        Address address = createAddress("seoul", "gaepo-dong", "42-42");
        StoreUserCmdDto dto = createCmdDto(address, "nakim");
        StoreUser storeUser = createStoreUser(address, "Hakim");
       //when
        when(storeUserRepository.save(any(StoreUser.class))).thenReturn(storeUser);
        //then
        UUID registerUserId = storeUserService.registerStoreUser(dto);
        assertEquals(registerUserId, storeUser.getId());

private StoreUser createStoreUser(Address address, String name) {
        return new StoreUser(UUID.randomUUID(), name, address);
    }
}
```

> 공식 문서  
[Mockito docs](https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html)  
[좋은 테스트를 작성하는 방법](https://github.com/mockito/mockito/wiki/How-to-write-good-tests)

> 그 외 참고  
[[SpringBoot] @Mock, @MockBean 차이가 뭘까?](https://blusky10.tistory.com/330)  
[Mockito @Mock @MockBean @Spy @SpyBean 차이점 정리](https://cobbybb.tistory.com/16)

## 문제 : update 함수는 어떻게 구성 해야 할까?

모든 정보를 업데이트 할수도 있고 아니면 하나의 항목 또는 두개의 항목을 선택해서 업데이트를 한다면
update함수를 속성마다 setter만들 듯 만들어야 하는지 아니면 한번에 덮어 씌우듯 해야 하는지 몰랐습니다.

```java
@Override
public StoreUserCmdDto updateStoreUserInfo(UUID userId, StoreUserCmdDto dto) {
        StoreUser findStoreUser = storeUserRepository.findById(userId).orElseThrow();
        findStoreUser.update(transferDtoToEntity(dto));
        return transferEntityToDto(findStoreUser);
}
```

## 해결 : JPA의 상태 감지를 활용하자!

JPA의 Merge기능은 모든 필드를 변경해버리고, 데이터가 없으면 null로 업데이트 합니다. Merge를 사용하려고 하면 모든 데이터를 유지해야하는데 변경 가능한 부분만 노출하려고 한다면 적합하지 않습니다.
그래서 Transaction이 있는 Service계층에서 변경 감지를 사용하도록 합니다.
업데이트 메서드를 하나로 통합해서 처리 가능하지 않을까 싶습니다.

그래서 저는 아래와 같은 방식으로 진행하려고 합니다.
1. ID와 변경 할 DTO를 전달 받습니다.
2. ID를 통해 영속 상태의 엔티티를 조회합니다.
3. 엔티티의 데이터를 변경합니다.
4. 커밋 시점에 상태감지가 실행되어 업데이트가 됩니다.

```java
@Override
public StoreUserCmdDto updateStoreUserInfo(UUID userId, StoreUserCmdDto dto) {
        StoreUser findStoreUser = storeUserRepository.findById(userId).orElseThrow();
        findStoreUser.update(transferDtoToEntity(dto));
        return transferEntityToDto(findStoreUser);
}

// StoreUser의 update method
public void update(StoreUser dto) {
        super.update(dto.getName(), dto.getAddress());
        this.store = dto.getStore();
}
```

> 공식 문서  
> [DataJPA 상태 감지 전략](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#reference)  

