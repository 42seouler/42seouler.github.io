---
title: albacorn 개인 프로젝트 과정 02.

layout: single

author_profile: true

read_time: false

comments: true

share: true

related: true

categories:
- Java

tag:
- spring

description: Spring security를 적용하는 이야기

meta_keywords: Java, Spring

last_modified_at: '2021-01-16 14:00:00 +08000'

toc: true

toc_sticky: true

toc_label: 목차
popular: true
---
<br>
## 문제 : 로그인 유저 정보는 어떻게?

저는 지금까지 테스트를 할 때 url_path는 /userid 로 요청을 했습니다.
그런데 아래의 코드를 작성 하면서 의문점이 생겼습니다.  
서버측에선 어떻게 유저의 정보를 식별하고 작동하는지 의문이 들었습니다.  
jwt토큰을 사용해서 userid를 줄 수 있다는 정보만을 얼핏 들었습니다.  
그렇다면 시작점이 userid이기 때문에 비효율적 이라고 생각 되었습니다.  
그래서 이 점을 찾아 보고 코드를 작성하기로 하였습니다.


```java
@Override
 public Long create(UUID storeId, JobPostCmdDto dto) {
     Store findStore = storeRepository.findById(storeId).orElseThrow();
     JobPost newJobPost = new JobPost(findStore, dto.getTitle(), dto.getBody());
     jobPostRepository.save(newJobPost);
     // 구인공고가 올라갔으니
     // 구인공고중이라고 store의 상태를 변경해줘
     return newJobPost.getId();
 }
```
## 해결 : http, spring security를 공부하자!

http는 비연결형 통신으로 요청과 응답이 되면 연결이 끊어집니다.  
그렇다면 우리가 흔히 알고 있는 로그인은 어떻게 되는 걸까요?  
유저가 로그인을 유지 하는 방법은 두가지가 있다고 합니다.
1. 세션으로 로그인하기.
2. jwt토큰으로 로그인하기. 
   
요즘 jwt토큰을 주로 사용한다고 해서 자세히 살펴보고자 한다.
토큰의 페이로드 부분에 내가 원하는 정보는 key : value로 담을 수 있습니다.  
민감한 정보가 아니라면 토큰에 같이 보내 줄 수 있음을 확인 했습니다.

> 공식 문서  
[스프링 시큐리티 공식 문서](https://docs.spring.io/spring-security/site/docs/5.4.2/reference/html5/#introduction)  
[네이버 OAuth](https://d2.naver.com/helloworld/24942)  
[JWT 공식문서](https://jwt.io/introduction/)


>참고 자료  
[JWT 외국 자료](https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage)  
[로그인은 어떻게 이루어질까❓(Cookie, Session)](https://velog.io/@junhok82/%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9D%B4%EB%A3%A8%EC%96%B4%EC%A7%88%EA%B9%8CCookie-Session)  
[풀스텍 개발자의 웹 프로그래밍](https://brunch.co.kr/@springboot/491)  
[jwt에서 정보 파싱하기](https://mia-dahae.tistory.com/122)  
[jwt 자바 가이드](https://medium.com/@OutOfBedlam/jwt-%EC%9E%90%EB%B0%94-%EA%B0%80%EC%9D%B4%EB%93%9C-53ccd7b2ba10)  

## 객체 관계를 설정하는게 어렵다.

처음엔 머리속에 있는 생각대로 클래스를 만들고 관계를 연결 했었습니다.  
그렇게 만들다보니 너무 많은 것들이 필요하기도 했고 순환참조처럼 연결 되었습니다.  
결국 클래스로 표현하되 연결은 ERD를 활용해서 도식화 하기로 했습니다.  
나이는 (20 ~ 25세이하)같은 어떻게 해야할지 몰라서 모름으로 일단 표시해두었습니다.

![](https://images.velog.io/images/memorego/post/572ec5d3-18d4-41b8-82e5-01315a0a03a0/Untitled%20Diagram%20(2).jpg)

굉장히 단순한 구조이지만 위의 그림을 그리는데 굉장히 오래 걸렸습니다.  
처음엔 Store와 Post 사이에 포스트의 상태에 따라 Store가 검색 가능 하도록   
하는 중간 객체를 두기로 했습니다. 두번째엔 주소 변경에 따라 가까운 지하철역을  
바꾸는 중간 객체도 만들기도 했습니다.  
세번째엔 지하철역과 포스트를 통합 관리하는 중간 객체를 만들기도 했습니다.  
생각 할 땐 불 필요한 객체인지 인지 못했고 Service계층에서 대략 알았습니다.  
아마도 제가 SQL을 잘 몰라서 생기는 문제 인 것 같았습니다.  
쿼리문을 통해 조회하면 되는데 중간객체의 상태를 조회해서 해결 하겠단 생각에  
객체 생성, 수정 삭제를 할 때 중간 객체 없이는 되지 않아서 굉장히 복잡 했었습니다.

## 데이터 시퀀스를 그려보자

시퀀스 다이어그램을 그리는것도 처음이라 단순하지만 정말 오래 걸렸습니다.  
아마 제대로 그리지 못했을 확률이 높지만 흐름을 파악하기 위해 작성했습니다.

![](https://images.velog.io/images/memorego/post/6e5e2cc6-b151-4621-9171-3b19db0fb1b7/Untitled%20Diagram%20(1).jpg)

검색에 필요한 파라미터를 조합해서 요청을 보내면 서비스에서 요청에  
null이 있다면 기본값으로 설정 해주고 dsl를 사용하는 흐름을 구상 하였습니다.
